/***
*resumable
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose: Library support of stackless resumable functions
*         http://isocpp.org/files/papers/N4134.pdf
*
*       [Public]
*
****/
#pragma once
#ifndef _RESUMABLE_
#define _RESUMABLE_
#ifndef RC_INVOKED
#include <new>
#include <memory>
#if _HAS_EXCEPTIONS
#include <exception>
#endif
#include <type_traits>

#pragma pack(push,_CRT_PACKING)
#pragma push_macro("new")
#undef new

_STD_BEGIN

namespace experimental {

	// TEMPLATE CLASS resumable_traits
	template <typename _Ret,
		typename... _Ts>
	struct resumable_traits
	{
		using promise_type = typename _Ret::promise_type;
	};

	// TEMPLATE CLASS resumable_handle
	template <typename _PromiseT = void>
	struct resumable_handle;

	// TEMPLATE CLASS resumable_handle<void> - no promise access
	template <>
	struct resumable_handle<void>
	{
		resumable_handle() noexcept = default;

		explicit resumable_handle(std::nullptr_t) noexcept
			: _Ptr(nullptr)
		{
		}

		resumable_handle& operator=(nullptr_t) noexcept
		{
			_Ptr = nullptr;
			return *this;
		}

		static resumable_handle from_address(void* _Addr) noexcept
		{
			resumable_handle _Result;
			_Result._Ptr = reinterpret_cast<_Resumable_frame_prefix*>(_Addr);
			return _Result;
		}

		void* to_address() const noexcept
		{
			return _Ptr;
		}

		void operator()() const noexcept
		{
			_Ptr->_Fn(nullptr, _Ptr);
		}

		explicit operator bool() const noexcept
		{
			return _Ptr != nullptr;
		}

		struct _Resumable_frame_prefix
		{
			typedef void (__cdecl *_Resume_fn)(void*, void*);
			_Resume_fn _Fn;
		};

	protected:
		_Resumable_frame_prefix* _Ptr;
	};

	// TEMPLATE CLASS resumable_handle<_PromiseT> - general form
	template <typename _PromiseT>
	struct resumable_handle
		: resumable_handle<>
	{
		resumable_handle() noexcept = default;

		using resumable_handle<>::resumable_handle;

		static resumable_handle from_promise(_PromiseT* _Prom) noexcept
		{
			auto _FramePtr = reinterpret_cast<char*>(_Prom) + _ALIGNED_SIZE;
			resumable_handle<_PromiseT> _Result;
			_Result._Ptr = reinterpret_cast<_Resumable_frame_prefix*>(_FramePtr);
			return _Result;
		}

		resumable_handle& operator=(nullptr_t) noexcept
		{
			_Ptr = nullptr;
			return *this;
		}

		static const size_t _ALIGN_REQ = sizeof(void*) * 2;

		static const size_t _ALIGNED_SIZE =
			is_empty<_PromiseT>::value
			? 0
			: ((sizeof(_PromiseT) + _ALIGN_REQ - 1) & ~(_ALIGN_REQ - 1));

		_PromiseT& promise() noexcept
		{
			return *reinterpret_cast<_PromiseT*>(reinterpret_cast<char*>(_Ptr) - _ALIGNED_SIZE);
		}

		_PromiseT const& promise() const noexcept
		{
			return *reinterpret_cast<_PromiseT const*>(reinterpret_cast<char const*>(_Ptr) - _ALIGNED_SIZE);
		}
	};

	template <typename _PromiseT>
	bool operator==(resumable_handle<_PromiseT> const& _Left,
		resumable_handle<_PromiseT> const& _Right) noexcept
	{
		return _Left.to_address() == _Right.to_address();
	}

	template <typename _PromiseT>
	bool operator!=(resumable_handle<_PromiseT> const& _Left,
		resumable_handle<_PromiseT> const& _Right) noexcept
	{
		return !(_Left == _Right);
	}

	// trivial awaitables

	struct suspend_if
	{
		bool _Ready;

		explicit suspend_if(bool _Condition) noexcept
			: _Ready(!_Condition)
		{
		}

		bool await_ready() noexcept
		{
			return _Ready;
		}

		void await_suspend(resumable_handle<>) noexcept
		{
		}

		void await_resume() noexcept
		{
		}
	};

	struct suspend_always
	{
		bool await_ready() noexcept
		{
			return false;
		}

		void await_suspend(resumable_handle<>) noexcept
		{
		}

		void await_resume() noexcept
		{
		}
	};

	struct suspend_never
	{
		bool await_ready() noexcept
		{
			return true;
		}

		void await_suspend(resumable_handle<>) noexcept
		{
		}

		void await_resume() noexcept
		{
		}
	};

	// defaults to std::allocator<char> if _Ty::allocator_type does not exist

	template<typename _Ty>
	struct _Get_resumable_alloc_type
	_GET_TYPE_OR_DEFAULT(allocator_type,
		allocator<char>);

	// _Resumable_helper_traits class isolates front-end from public surface naming changes

	template <typename _Ret,
		typename... _Ts>
	struct _Resumable_helper_traits
	{
		using _Traits = resumable_traits<_Ret, _Ts...>;
		using _PromiseT = typename _Traits::promise_type;
		using _Alloc_type = typename _Get_resumable_alloc_type<_Traits>::type;
		using _Alloc_traits = allocator_traits<_Alloc_type>;
		using _Alloc_of_char_type = typename _Alloc_traits::template rebind_alloc<char>;
		using _Alloc_char_traits = allocator_traits<_Alloc_of_char_type>;
		using _Handle_type = resumable_handle<_PromiseT>;

		static _PromiseT * _Promise_from_frame(void* _Addr) noexcept
		{
			return reinterpret_cast<_PromiseT*>(reinterpret_cast<char*>(_Addr) - _Handle_type::_ALIGNED_SIZE);
		}

		static _Handle_type _Handle_from_frame(void* _Addr) noexcept
		{
			return _Handle_type::from_promise(_Promise_from_frame(_Addr));
		}

		static decltype(auto) _Create_return_object(void* _Addr)
		{
			return _Promise_from_frame(_Addr)->get_return_object();
		}

		static decltype(auto) _Initial_suspend(void* _Addr)
		{
			return _Promise_from_frame(_Addr)->initial_suspend();
		}

		static decltype(auto) _Final_suspend(void* _Addr)
		{
			return _Promise_from_frame(_Addr)->final_suspend();
		}

		template <typename _Ty>
		static auto _Set_result(_Ty* _Addr) -> decltype(_Promise_from_frame(_Addr)->set_result())
		{
			_Promise_from_frame(_Addr)->set_result();
		}

		template <typename _Ty>
		static auto _Set_result_if_present(int, _Ty* _Addr) -> decltype(_Promise_from_frame(_Addr)->set_result())
		{
			_Promise_from_frame(_Addr)->set_result();
		}

		template <typename _Ty>
		static auto _Set_result_if_present(_Wrap_int, _Ty*) -> void
		{ // no set_value to call
		}

		static void _Graceful_completion(void* _Addr)
		{
			_Set_result_if_present(0, _Addr);
		}

		template <typename _Ty>
		static void _Set_result(void* _Addr, _Ty&& _Expr)
		{
			return _Promise_from_frame(_Addr)->set_result(_STD forward<_Ty>(_Expr));
		}

		template <typename _Ty>
		static decltype(auto) _Yield_value(void* _Addr, _Ty&& _Expr)
		{
			return _Promise_from_frame(_Addr)->yield_value(_STD forward<_Ty>(_Expr));
		}

		static bool _Check_cancel(void* _Addr)
		{
			return _Promise_from_frame(_Addr)->cancellation_requested();
		}

#if _HAS_EXCEPTIONS
		static void _Set_exception(void* _Addr)
		{
			_Promise_from_frame(_Addr)->set_exception(_STD current_exception());
		}
#endif

		// helper to free up memory if promise ctor or dtor throws
		struct _SafePtr
		{
			_SafePtr(void* _Pt, size_t _Sz) noexcept
				: _Ptr(reinterpret_cast<char*>(_Pt))
				, _Size(_Sz)
			{
			}

			~_SafePtr() noexcept
			{
				if (_Ptr)
				{
					_Alloc_of_char_type _Alloc;
					_Alloc_char_traits::deallocate(_Alloc, _Ptr, _Size);
				}
			}

			static _SafePtr _Alloc(size_t _Sz)
			{
				_Alloc_of_char_type _Alloc;
				return _SafePtr(_Alloc_char_traits::allocate(_Alloc, _Sz), _Sz);
			}

			auto _Get() const noexcept
			{
				return _Ptr;
			}

			void _Detach() noexcept
			{
				_Ptr = nullptr;
			}

		private:
			char * _Ptr;
			size_t _Size;
		};

		__declspec(noinline) static void* _Alloc(size_t _Frame_size, void* _Resume_address)
		{
			auto _Size = _Frame_size + _Handle_type::_ALIGNED_SIZE;
			// TODO: wrap around check in BE, no need to do it at runtime

			auto _Ptr = _SafePtr::_Alloc(_Size);
			auto _Frame_ptr = _Ptr._Get() + _Handle_type::_ALIGNED_SIZE;

			new (static_cast<void*>(_Ptr._Get())) _PromiseT();
			_Ptr._Detach();

			*reinterpret_cast<void**>(_Frame_ptr) = _Resume_address;

			return _Frame_ptr;
		}

		__declspec(noinline) static void _Free(void* _Frame_ptr, size_t _Size)
		{
			_Size += _Handle_type::_ALIGNED_SIZE;
			auto _Prom = _SafePtr(_Promise_from_frame(_Frame_ptr), _Size);
			reinterpret_cast<_PromiseT*>(_Prom._Get())->~_PromiseT();
		}

	}; // _Resumable_helper_traits

} // namespace experimental

_STD_END

// resumable functions support intrinsics

extern "C" size_t _resumable_frame_size();
extern "C" void* _resumable_frame_ptr();
extern "C" void* _resumable_catch_frame_ptr();
extern "C" void* _resumable_resume_addr();
extern "C" void _resumable_init_frame(void*);
extern "C" void _resumable_save();
extern "C" void _resumable_suspend();
extern "C" void _resumable_cancel();
extern "C" void _resumable_destroy_formals();

#pragma intrinsic(_resumable_frame_size)
#pragma intrinsic(_resumable_frame_ptr)
#pragma intrinsic(_resumable_catch_frame_ptr)
#pragma intrinsic(_resumable_resume_addr)
#pragma intrinsic(_resumable_init_frame)
#pragma intrinsic(_resumable_save)
#pragma intrinsic(_resumable_suspend)
#pragma intrinsic(_resumable_cancel)
#pragma intrinsic(_resumable_destroy_formals)

#pragma pop_macro("new")
#pragma pack(pop)
#endif /* RC_INVOKED */
#endif /* _RESUMABLE_ */
